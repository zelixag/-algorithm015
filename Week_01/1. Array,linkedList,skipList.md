## 数组、链表、跳表的基本特性和实现
### Array

1. 声明一个数组即获得一个连续的内存空间
2. 每一个数组元素都有一个内存地址，任何一个元素的访问时间一样，所以访问速度很快

数组插入 时间复杂度 差 o(n)
将插入的位置的内存进空间拿出来，后面的元素复制并往后移一位。会有很多数组片段的复制赋值


删除

数组查询快 增删改都比较慢

### linked List

1. 在一些修改和添加操作删除的有比较频繁的操作，数组这种数据结构就不太适合，就适合使用链表。

2. 元素定义好之后，有两个属性 一个是next（指是下一个元素） 另一个是value（元素值 为对象）
c
3. 需要强调的一点是一个节点一般都是一个类class，一般都叫node
4. 一个next就是单链表 有两个指针 一个是next 另一个是先前指针叫做 prev，既能往后面走也能往前面走， 则称为双链表。
5. 头指正 head 尾指针 tail 最后一个元素next指向为null空。如果最后一个元素还会指向head元素，则称为循环链表

### 链表的增加和删除操作
1. 链表的标准实现
   ```java
    class LinkList {
      Node head; // head of list

      /* Linked list Node */
      class Node {
        int data;
        Node next;

        // constructor to create a new node
        // Next is by default initialized
        // 构造函数
        Node(int d) {data = d}
      }
    }
   ```
2. 添加
   1. 插入一个节点，先断开插入位置的前后树，就是将前一个next指向新插入node再将新插入的next指向后一个node元素
  是 常数级别的操作 为o(1)
3. 删除
   1. 是增加节点的逆操作
   2. 删除目标节点为 target Node 吧targetNode前一个节点打掉断开，在指向targetNode后一个节点，即删除targetNode的指向

4. 总结： 
   1. 从新增和插入节点操作发现，如果增加或者删除任何节点，他没有引起整个链表的群移操作，也不需要复制元素，再挪动一般的元素或者是挪动多个元素到新的位置。正是以为有这些常数级的操作有点，所以他移动和修改操作的效率非常高， 为o(1).
   2. 但是也是因为这样一个结构，导致了你要访问这个链表中任何一个位置，操作都不会简单，举个例子你要访问头结点和尾结点很容易就是o（1）。在最中间的位置访问的话，必须在头结点一步一步往后挪，知道访问到这个中间节点，复杂度o(n)

5. linked list 时间复杂度
   操作 | 链表时间复杂度（平均值）| 链表时间复杂度（平均值                  
   --- | ---|---
   prepend | o(1)| o(1)（优化到o(1)）
   append | o(1)|o(1)（优化到o(1)）
   lookup | <font color="red">o(n)</font>|o(1)
   insert | o(1)|<font color="red">o(n)</font>
   delete | o(1)|<font color="red">o(n)</font>

  - 数组的时间复杂度
    - prepend 注意： 
      - 正常情况下数组的prepend操作时间复杂度是o（n），但是可以进行特殊优化到o（1）。采用的方式是申请稍大一些的内存空间，然后在数组的最开始预留一部分空间，然后preend的操作则是把头下表前移一个位置即可
      - 
查询链表的任意node的平均复杂度是o（n）这也是链表操作的问题所在。查询复杂度是线性的，复杂度高


### 总结 
任何数据结构并不是百分之百优秀的。如果有完美的话，就不需要数组和链表两种数据结构了，就直接用最牛逼的数据结构即可。我们应当各取所长，看你的使用场景是什么样的

### 跳表
从这两个数据结构，科学家们就研究出一个较好的数据结构，跳表
1. 链表元素有序的时候，即使使用链表这种数据结构存储的话，我们会发现它的元素是有序的。如果有序的数组，使用二分查找算法可以很快的找到元素的位置

以及查询到一个元素是否在有序的数组中存在。

思考： 如果是有序链表，怎样可以将查询速度变快？

在1990年前后，一种新的数据机构出现： **跳表**
  #### 跳表
    注意： 只用于元素有序的情况

    所以，跳表（skip list）对标的是平衡树（AVL Tree）和二分查找。是一种 插入、删除、搜索都是o(log n)的数据结构。1989年出现。

    他最大的优势是原理简单，容易实现，方便扩展，效率更高。因此在一些热门的项目里用来代替平衡树，如Redis levelDB等

 <font COLOR=RED SIZE=5>  跳表里面的元素始终是有序的</FONT>
 跳表对标的是平衡树，也就是二叉树搜索树种的平衡树和二分查找

1990年前后，一种新的数据结构跳表出现了，虽然跳表本身是基于链表的，但是他的出现比平衡树和二分查找以及所谓的一些高级的数据结构出现的要晚。

注意很重要的一点（非常重要）： 跳表的使用智能用于链表里的元素有序的情况下，跳表对标的是平衡树，也就是二叉搜索树中的平衡树和二分查找。平衡树和二叉树都是1960年左右出现。跳表比他们晚接近30年。老的算法使用平衡二叉树多一点，而一些比较新的特别是在元素的个数不多的情况下用的全部都是跳表。


### 如何给有序的链表加速

<font COLOR=RED SIZE=4>算法训练营思想：像链表这个结构是一维的结构，而且是有序的，
也就是我们附加的信息。这种加速有点类似于星际穿越的里面的加速，类似于玄学。
但是你一定要记住一个概念就行了。一维数据加速经常采用的方式是升维也就是变成二维，
为什么要多一层维度呢，因为你多了一个维度之后，就会有多一级的信息在里面。
这样多一级的信息就帮助你可以很快的得到一维里面你必须挨个走才能走到的那些元素</FONT>

### 添加第一级索引（n/2）
如何提高链表的线性查找的效率？


### 小结

  - 数组、链表、跳表、的原理和实现
  - 三者的时间复杂度、空间复杂度
  - 工程运用
  - 跳表： 升维思想 + 空间换时间

尤其是数组和链表，他们的增加删除访问的时间复杂度，大家一定要非常的清晰，这个在面试的时候经常会问，而且的话会根据不同的面试题的话，
就是来考察你用哪一种数据结构是否考虑的得当

在工程运用方面，比如说Redis里面用的是什么， 或者LRU Cache的话用的是什么。这个了解即可

算法思维（很重要）： 升维思想 第二就是空间换时间