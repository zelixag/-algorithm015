## 盛水最多的容器（腾讯、百度、字节跳动在近半年内面试常考） 和 爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考）

### 盛水最多的容器
   解决问题的办法：先想出最简单的方法在想较难的方法，先开拖拉机再开法拉第
   1 最简单最暴力枚举： 不管你左边有多大右边有多大，不管你容器有多大，高度有多少，它肯定有左边界又边界 left bar right bar （x-y）* height——diff（O（n^2））
      重点提下： 遍历数组常见方法
  如果你要遍历左和有边界的话， 且左右遍历它本来不能重复我们怎么办呢？这个再面试中，很多候选人都不太熟练。一定要记下来。下面的代码就可以实现i 和 j对这个数组的遍历，且保证i和j不会重复，且不会有反复这么一个值。所以 这样是最简化的一个两层遍历
  ```js
    for(let i = 0;i< a.length - 1; ++i) {
      for(let j = i+ 1;j<a.length;j++) {}
    }
  ```
  在使用自顶向下编程
  ```js
    for(let i = 0;i< a.length - 1; ++i) {
      for(let j = i+ 1;j<a.length;j++) {
        const area = _getArea(i, j)
      }
    }
  ```
  得到了area之后还要记录每次最大的一个值

  第二个方法就是从最终两段往里面挪，这样我们能够确定宽度是最长的，只要筛选出两个较高的两个柱子就是面积最大的，装水就是最低的决定，所以取两根柱子较小的那个乘以宽度得出面积，得出的面积跟每次遍历出来的最大面积比较，缺最大值

  左右边界向中间收敛复杂度是o（n）

  ### 爬楼梯问题

  1.解题思路，能不能暴力？基本情况？化繁为简

      算法思想： 找最近 重复子问题
      为什么找子问题呢，因为在现在的程序都是只有顺序，分支，循环子。，然后就是程序不断调自己和递归。除了前面if else 这种巨简单的问题之外，其他的就是for while
      recursion的不断的重复。究其原因，计算机是人类发明的，那么人类发明出来的工具肯定没有人脑这么强，其实就是一个简单的重新的机器，加上我们现在用的这些程序都是最简单的程序或算法，
      不涉及任何关于人工智能的东西，你就把他想成一个不断重复在哪里干事情的东西就好了。所以要使用重复的东西解决这个问题的话，说明这个问题本身就是可重复的。想完这个思想之后，讲什么回溯，动态规划呀，递归全部都是在使用循环去做一件事情找重复性

      if else for while recursion 计算机就是
当道第三级台阶的时候你应该想，只有两种方法。一种是在第二级台阶跨一步到第三级台阶，另一种就是在第一级台阶跨两步上第三级台阶
所以到第三级有两种可能 但是前提是达到了第一级台阶或者是第二级台阶 所以从0到第三级台阶一共有 到第一级台阶和第二级台阶的方法相加 f(3) = f(1) + f(2)

这样即可推出 f(n) = f(n - 1) + f(n -2)
  1： 1
  2： 2
  3： f(1)+ f(2)
  4： f(2) + f(3)

  ...
  （数学归纳法）退出斐波那契的算法
  fn(n) = f(n - 1) + f(n-2) : fibonacci算法 

  很多人看到算法，都觉得难或者没有思路或者感觉特别沮丧，就是因为被打击了自信心？或者说无聊，基本上没有把很多文章也好老师也好没有把这个思想讲清楚，思想很重要。

        重要思想：  1. 懵逼的时候你就想一想能不能暴力解
                  2. 暴力不能解决，还有一种方法就是想最简单的问题是什么（比如爬楼梯，你就想一级台阶几种方法，二级台阶几种方法，第二级到第三级有几种，推出0到三级有几种方法）记住程序只会处理出分支循环能够解决的问题。
                  3. 想出简单问题之后，想一下怎么泛化。泛化的思路就是找重复的问题，这里是找 最近子问题。为什么叫最近（后面再讲</font>）如果问题找的太远的话，就会分析起来很累很麻烦
                  4. 找重复性即可，为什么要找重复性呢？因为我们的计算机只能做 if else for loop recursion这些动作，正是这个原因，程序层层嵌套在一起，最后你会发现，你的思路最后把所有题目都只能往这个方向去做和思考。
                  5. 这么一想我们就觉得万事万物其实就那么一点，就很简单，其实也就是这样，学过物理就知道，最后定理就是那么几个，最后的话就有一个大一统的理论，比如说弦理论。。。。现在只要广义相对论和量子力学之间的关系

总之： <font COLOR=RED>找重复性，找重复性 找重复性</FONT> 因为我们的程序傻儿吧唧的，只会做重复性的事情 。

做重复性的时候我们可以if else出很多分支，这样的话就会让你的所谓的递归的程序就会越来越复杂越来越复杂，程序的复杂性就出来了。

```js
// 利用数组代表函数，并且存住以前的初始值
var climbStairs = function foo(n) {
  let dp = []
  dp[1] = 1
  dp[2] = 2
  for(let i = 3; i <= n; i++) {
      dp[i] = dp[i - 2] + dp[i - 1]
  }
  return dp[n]
};
```

大家吃饭的时候，闲时都可以去思考老师说的这些思考，想清楚了你就会觉得你对计算机的理解 算法的理解更上一层楼。加油