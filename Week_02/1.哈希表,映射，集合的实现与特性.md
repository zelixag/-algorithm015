### 哈希表、映射、集合

现实中用的更多的或者更加复杂的数据结构
1. 首先用的最多的是数组链表，和map set底层结构都是使用hashtable来实现的


### Hash Table
哈希表，也叫散列表，是更具关键码值（key value）而直接进行访问的数据结构
他通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度
这个映射函数叫做散列函数（Hash Function）， 存放记录的数组叫作哈希表（或散列表）

就是能够吧值映射到一个位置，这个位置就是他的下标index，就任何一个对象传过来或者任何一个数据传进来
这个数据比如说是string，他会映射到一个int的下标，然后放在数组中即可。

### 项目中现实例子
当你存放一些数据根据这个人或者更具某一个具体的的对象来存它的相对应的信息比如说人的话有他的有地址信息，地址信息各种各样的信息，
我们就以这个人的人名或者他的身份证号码作为他的id，然后后面的话就记录他各种信息这种。
- 电话号码本，
- 用户信息表
- 缓存（LRU Cache）
- 键值对存储
  
  上面这些数据的存放都用了大量的hashtable

### hash Function
哈希表的实现原理是什么？如何存储一个字符串？

首先要存储的值是’lies‘，有一个想哈希函数这样一个东西，lies传给hashFunction之后就会返回一个下标，这个下标的话就是整数。

现实当中的函数较为复杂，而且hash函数选的好的话，可以让这些数值尽量的分散，而不会发生所谓的碰撞。如果下标的数值不分散很有可能下标一样。

有可能不同两个字符串算出来的数值下标相同，这种情况就是hash碰撞（hash Collisions）。

现在比较火的区块链比特币以及大数据里面的经常都会用到hash。

解决hash碰撞，在项目当中一般采用的方式是增加一个维度，这样这个位置就不是一个数了，而是存多个数，也就是拉出来一个链表。这个方法就是叫做TODO:S拉链式解决冲突发

那么把都应该放在9这个位置的元素，一个数据进入hashfunction后得到该数据的hash值，这个查询时间复杂度O(1),但是如果很多的元素都积累在这里相同放入位置，这时候hash表的他的查询时间就要遍历链表对不对

所以的话这时候如果链表很长的话就会效率进行退化。退化到所谓的o(n)级别，但是如果你设计的比较好的话，hash碰撞的概率比较小，所以平均的话复杂度o(1)

发生hash碰撞之后这里就拉链拉出来类似这种，大部分情况下一个元素都是完美hash的，只要少数的位置会有一些冲突，有冲突在这里累加起来就行，就是串联起来形成一个链表即可。
和之前所讲的优先队列一样以后面要讲的红黑树和AVL一样，像hash表以及常见的hash函数的话，在工程项目里面非常常用，所以高级的语言以及标准的库，比如说STl比如说java的各种库都实现了、


直接搜 java hashtable 查看简单使用

通常情况下hashtable查询 增加和删除都是复杂度o(1)。
最坏情况 hash函数选的非常不好或者hash表他的整个size太小了，就导致经常发生冲突，一发生冲突就变成一个链表了。
退化成链表复杂度就变成了o(N).
Hash开的大 hash函数不断优化，认为hash都是复杂度o（1）。

### 市场和工程代码hash table的使用

1.在真正的过程代码里，我们经常用的就不是hashtable（语言都会封装实现），而是在hash表基础上抽象出来的，使用的比较多就叫

  - Map key-value对，key不重复
    - new HashMap()/new TreeMap（）
    - set（）
    - get
    - has
    - size
    - clear
  
  - Set 不重复元素的几哈
    - new HashSet
    - add
    - delete
    - hash

java的set就是一个hashMap java感觉有点对象累赘
