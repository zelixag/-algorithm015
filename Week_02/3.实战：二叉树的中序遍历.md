## 树实战

一般树的面试题解法，都是递归，为什么呢？


第一个原因： 它的代码本身的话，树的定义没有所谓的它的后继（表示疑惑，时间00：23）这么一个结构或者说一个便于循环的结构，而是更多的是左节点右节点。这样的话你要去访问它的子树的话，更好的方式是直接对他的左节点再调相同的遍历函数

```java
// 树结构
public calss TreeNode {
  public int val;
  public TreeNode left, right;
  public TreeNode(int val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}
```

前中后序遍历最好记下来，形成机械记忆，本身的代码结构非常的严谨

### 树的遍历Demo
动态规划和递归相对都比较难。

递归不存在效率低效率差的问题，只要你的程序本身的话算法复杂度没有写残即可。

斐波那契你只是傻递归，没有把中间结果存储起来的话，导致本身线性可以解决的问题，需要指数级的时间复杂度才能解决的话，这是不合理的，但是锅本身不再递归上面.不是你用了递归导致卡死，而是你没有使用缓存。
其实他们的地方就是它要多开一些栈，如果递归太深的话会有效率低的问题，现在计算机存储方式和编译器对于递归特别是尾递归的优化的话，递归和循环一样效率，不需要规避