## 二维数据结构（树，二叉树，二叉搜索树）

（回顾）链表的话有head和tail 而且有个next指针不断的往后指，这是单链表。如果是双链表的话还有一个前继指针往前指，那之前他最大的问题就是查询的时候太慢
要O(n)的复杂度，为什么呢？你要查询中间的节点或者是第六个节点...第n个节点就会next一个一个往下查 知道查到结果为止。像蜗牛一样，正是因为这个原因的话，后来就出现了
一个叫跳表一样的结构，就加上了更快地索引（比如说从头指针直接跨到第二个节点）。

这里有个思想就是，要是提升速度就是要升维。

### 树和图
讲树之前，其实现在给大家想引出的一点就是，在单链表这里的话，如果它的next指正很多时候你会想想，不是一个next而是多个next，有next1 next2 next3指向多个节点的话，她就编程了树（tree）

他有根节点（root），左子树， 右子树。兄弟节点（siblings节点）父亲节点（parent Node） 子节点（Child Node） 树还有层级level 0 level 1 ....当然也可以从level 1 开始 

有父亲节点和子节点的大树里面的子树，

树和图最关键的一个差别是什么最关键点就是干结构有没有环

如果他这个节点值连接到一个新的节点，永远都不会走回去。就是有一个节点F他的子节点会指向F的兄弟节点或者父节点或者根节点形成环的情况下都是图
但是在特殊情况下，只有一个next指针的树的就是图，没有环的图就是树

### 树的节点的定义
java

  ```java
    public TreeNode(int val) {
      this.val = val
      this.lift = null
      this.right = null
    }
  ```

### 为什么会出现树
从工程中来说，出现树的本质，并不是说一定要一维的结构不好用，要变个二维的结构出来给大家fancy（耍酷）一把或者说因为一维太慢了要变成树加速类似这样的（其实跳表也就可以加速）。
出现树的原因因为我们人类本身生活在一个三维的世界里面，四维的世界里面当然也包括了二维，所以人类很多本身他的工程实践，其实就是在二维的基础上要去解决的，而树本身的话就是人经常会碰到的一种情况。就类似与飞机不是人发明和创造的而是看到鸟在飞时候想到的，仿生研究出来。飞的能力。
最常见的就是fibonnacci数组求解的时候，暴力定会就两行很简单
```js
  fib(n) {
    if(n === 1 || n === 2) return 1
    return fib(n-1)+fib(n-2)
  }
  ```
  但其实它扩散出去的节点其实是一个树状的节点，假设算n=20的时候画出的递归树，从20的时候可以扩散出递归不同状态的节点，我们叫他**递归状态树（递归树）**，本身就是一个树形结构。
  另外比较火的阿尔法go以及各种棋类的游戏，不管你谁哪一个选手开始下了之后，这个棋盘的状态就是向外扩散成不同的状态。每个不同的状态再往下面走，棋盘状态本身的话它也是一个树形结构，
  三子棋 空棋盘是初始状态，每一个人他都可以走不同的步，走了之后棋盘就往下，继续扩散出不同的状态，形成第二层第三层第四层的树的节点。
  到了最后所谓的叶子节点就是这个棋盘的终极形态，终极形态肯定不能往下了。或赢或输或和棋。不同棋的树的空间我们叫他状态树的空间，还有一个叫博弈的空间也可以叫做你的decision tree决策树的空间的复杂度不一样

  最后决定了这个棋或者这个游戏他的复杂度。围棋状态空间特别大。

  人生本身就是一棵树 每次选择都是每个节点分叉.

### 二叉树
  显示用的最多的就是二叉树（就是每个父亲节只有两个子节点）

### 二叉树遍历
  1. 前序（Pre-order）： 根-左-右
  2. 中序（In-order）：左-根-右
  3. 后序（Post-order）： 左-右-根

为什么要遍历树呢，以为结构的话数组或者链表，你要查询你的节点你就必须遍历，如果这是一颗非常基本的树，没有任何特征的话，就它的里面的节点群不是无序的话，
你要查找一个元素的话就必须要遍历，你遍历的话就是所有节点都走一遍。怎么走呢，其他的数据结构就循环一遍，一直到循环没有。因为它树状的话会有左子树右子树这么一种情况，那就类似的递归去把它反复的求证。
递归遍历就是做种后序遍历，因为你要查自己跟节点的值同时你还要访问你的左子树和右子树 总共需要三句语言的循序，最后就变成了不同的遍历方式。
树的遍历就是递归。

循环遍历二叉树，比如说用广度优先遍历，但是很多情况下，你会发现它这种结构的话，写循环先对比较麻烦。而写递归调用相对比较简单，你可以看到不同的序的遍历的话严格来说就是四行语句非常的漂亮

```python

  def preorder(self, root):

  if root:
    self.traverse_path.append(root.val)
    self.perorder(root.left)
    self.preorder(root.right)

  def inorder(self, root):

  if root:
    self.inorder(root.left)
    self.traverse_path.append(root.val)
    self.inorder(root.right)

  def postorder(self, root):

  if root:
    self.postorder(root.left)
    self.postorder(root.right)
    self.traverse_path.append(root.val)
```